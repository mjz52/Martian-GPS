% rotating_box.m  -Andy Ruina  Feb 20, 2019
% Aaron Brown
% February 27, 2020
% MAE 4161 Spacecraft Technology and Systems Architecture
% Simulation of a rotating box in space

clear; clc;  

% General Setup for time, the goal is to create tarray
tend        = 5;                        %  Ending time "t end"
npointspers = 100;                      %  number of h intervals per time unit
ntimes      = tend * npointspers + 1;   %  total number of time points
tarray      = linspace(0, tend, ntimes);%  All of the times soln is output

% Constants (SI)
p.I = [1 0 0; 0 1 0; 0 0 1];    % inertia tensor


r0= [100;0];  % Initial position
v0 = 500;  theta = pi/4;
v0= v0* [cos(theta); sin(theta)] ;  %turn a scalar into a vector :)

z0 = [r0;v0];                   % ICs, packed into a column vector

% Next  line gets the solution to the ODES
[tarray zarray]   = myMidpointSolver(@myrhs, tarray, z0, p);

t= tarray;
x = zarray(:,1); y = zarray(:,2);   % Extract the two columns of zarray

%PLOTS
figure(1); plot (x,y,'LineWidth',1); 
axis equal; shg                      % Plot y vx s
ylabel('$y$','interpreter','latex'); % Nice looking math
xlabel('$x$','Interpreter','latex'); 
title(['Trajectory. -A. Ruina   ' datestr(now)])

figure(2); plot(t,x, t,y); shg;
ylabel('$x,y$','interpreter','latex'); % Nice looking math
xlabel('t$','Interpreter','latex'); 
title(['Position vs time -A. Ruina   ' datestr(now)])

function  [tarray, zarray]   = myMidpointSolver(eqn, tarray, z0, p)
%Solves ODEs using midpoint (2n order RK) method
% eqn is the name of the RHS file
ntimes = length(tarray);     % number of times
zarray = zeros(ntimes, length(z0));  % Memory allocation


zarray(1,:) = z0';     % Set first row of soln to the ICs

for i  = 2:ntimes     % Once through the loop for each time interval
   h    = tarray(i) - tarray(i-1);       % size of time step
   z    = zarray(i-1,:)';   t = tarray(i-1);  % set present values
   
   %Midpoint method is the next four lines of code
   zdot = eqn(t,z,p);     % evaluate RSH (right hand side) at present time
    ztemp = z + zdot * h/2;   % half of one Euler-method time step.
   zdot = eqn(t+h/2,ztemp,p); % evaluate RHS (right hand side) at midpoint
   znew = z + zdot * h;   % one Midpoint-method time step.
 
   zarray(i,:) = znew'; % Add a row to the array of solutions. 
                        % Recall, z is a column, zarray is in rows.
 end % loop
end  % function

function zdot = myrhs(t,z,p)
% 2D particle motion, right hand side function
% LOTS OF DIFFERENT PROBLEMS HERE.
r = z(1:2);  v = z(3:4);   %Unpack z

jhat = [0;1]; % unit vector pointing up


% PICK ONE By uncommenting the lines defining F

%1) LINEAR DRAG, gravity is down
   F    =  -p.g * p.m * jhat - p.cl *  p.A * v ;

%2) QUADRATIC DRAG, gravity is down
%   F    = -p.g * p.m * jhat ...
%          - p.cq * p.rho * p.A * v * norm(v)/2;

%3) SPRING WITH ZERO REST LENGTH, no gravity
%   F    =  -p.k* r;

%4) SPRING, WITH GRAVITY
%   L    = norm(r);
%   stretch = L - p.L0
%   F    =  -p.k * stretch * r/L  -p.g * p.m * jhat ;

%5) INVERSE SQUARE GRAVITY. Sattelite around earth, Ballistic missile.
%   L    =  norm(r);
%   F    =  -p.m * p.g * (p.Re/L)^2 * r/L;


%Governing Equations
rdot = v;
vdot = F/p.m;

zdot = [rdot; vdot];
end